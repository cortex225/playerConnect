generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                     String         @id @default(cuid())
  name                   String?
  email                  String?        @unique
  image                  String?
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  role                   String         @default("USER")
  lastActivity           DateTime?
  stripeCustomerId       String?        @unique
  stripeSubscriptionId   String?        @unique
  stripePriceId          String?
  stripeCurrentPeriodEnd DateTime?
  emailVerified          Boolean        @default(false)
  password               String?
  accounts               Account[]
  athletes               Athlete?
  messagesReceived       Message[]      @relation("MessagesReceived")
  messagesSent           Message[]      @relation("MessagesSent")
  notifications          Notification[]
  recruiters             Recruiter?
  sessions               Session[]
  messages               Message[]      @relation("MessageToUser")

  @@map("users")
}

model Session {
  id        String   @id @default(cuid())
  token     String   @unique @map("sessionToken")
  userId    String
  createdAt DateTime @default(now())
  expiresAt DateTime
  ipAddress String?
  updatedAt DateTime @updatedAt
  userAgent String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Account {
  id                   String    @id @default(cuid())
  userId               String
  type                 String    @default("oauth")
  scope                String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  accessToken          String?
  accountId            String
  idToken              String?
  providerId           String
  refreshToken         String?
  sessionState         String?
  tokenType            String?
  accessTokenExpiresAt DateTime?
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("accounts")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

model Message {
  id          String   @id @default(cuid())
  content     String
  senderId    String
  recipientId String
  isRead      Boolean  @default(false)
  createdAt   DateTime @default(now())

  // Sécurité et modération
  isModerated Boolean  @default(false)
  isFlagged   Boolean  @default(false)
  flagReason  String?

  // Relations
  recipient   User     @relation("MessagesReceived", fields: [recipientId], references: [id], onDelete: Cascade)
  sender      User     @relation("MessagesSent", fields: [senderId], references: [id], onDelete: Cascade)
  User        User[]   @relation("MessageToUser")

  @@index([senderId, recipientId])
  @@index([createdAt])
  @@map("messages")
}

// Système de contacts approuvés pour les mineurs
model ApprovedContact {
  id          String   @id @default(cuid())
  userId      String   // L'ID du mineur
  contactId   String   // L'ID du contact approuvé (recruteur)
  approvedBy  String?  // Parent/tuteur qui a approuvé
  approvedAt  DateTime @default(now())
  expiresAt   DateTime? // Optionnel: date d'expiration de l'approbation
  isActive    Boolean  @default(true)

  @@unique([userId, contactId])
  @@index([userId])
  @@map("approved_contacts")
}

// Historique de modération
model ModerationLog {
  id          String   @id @default(cuid())
  messageId   String?
  userId      String   // Utilisateur concerné
  action      ModerationAction
  reason      String
  moderatedBy String?  // Système ou ID du modérateur
  createdAt   DateTime @default(now())
  metadata    String?  // JSON avec détails additionnels

  @@index([userId])
  @@index([createdAt])
  @@map("moderation_logs")
}

enum ModerationAction {
  FLAG
  WARN
  BLOCK
  DELETE
  APPROVE
}

model Sport {
  id        String     @id @default(cuid())
  name      SportType  @unique
  athletes  Athlete[]
  levels    Level[]
  positions Position[]

  @@map("sports")
}

model Position {
  id           String            @id @default(cuid())
  name         String
  sportId      String
  athletes     AthletePosition[]
  kpis         KPI[]
  performances Performance[]
  sport        Sport             @relation(fields: [sportId], references: [id], onDelete: Cascade)

  @@unique([name, sportId])
  @@map("positions")
}

model Level {
  id         String     @id @default(cuid())
  name       String
  sportId    String
  categories Category[]
  sport      Sport      @relation(fields: [sportId], references: [id], onDelete: Cascade)

  @@unique([name, sportId])
  @@map("levels")
}

model Category {
  id       String        @id @default(cuid())
  name     CategoryLevel
  levelId  String
  athletes Athlete[]
  level    Level         @relation(fields: [levelId], references: [id], onDelete: Cascade)

  @@unique([name, levelId])
  @@map("categories")
}

model Athlete {
  id            Int               @id @default(autoincrement())
  userId        String            @unique
  gender        Gender?
  age           Int?
  dateOfBirth   DateTime?         // Date de naissance pour vérifier si mineur
  city          String?
  country       String?           // Pour le ranking national
  region        String?           // Pour le ranking régional
  height        Float?
  weight        Float?
  dominantHand  DominantHand?
  dominantFoot  DominantFoot?
  programType   ProgramType?
  categoryId    String?
  sportId       String?

  // Protection des mineurs
  parentalConsentRequired Boolean @default(false)
  parentalConsentGiven    Boolean @default(false)
  parentEmail             String?

  // Gamification & Ranking
  totalScore    Float             @default(0) // Score total calculé
  level         Int               @default(1) // Niveau de gamification
  xp            Int               @default(0) // Points d'expérience

  positions     AthletePosition[]
  category      Category?         @relation(fields: [categoryId], references: [id])
  sport         Sport?            @relation(fields: [sportId], references: [id])
  user          User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  events        Event[]
  media         Media[]
  notifications Notification[]
  performances  Performance[]
  rankings      Ranking[]
  badges        AthleteBadge[]

  @@map("athletes")
}

model AthletePosition {
  id         String   @id @default(cuid())
  athleteId  Int
  positionId String
  athlete    Athlete  @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)
}

model Performance {
  id         Int      @id @default(autoincrement())
  athleteId  Int
  positionId String
  date       DateTime
  score      Float
  KPI        KPI[]
  athlete    Athlete  @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)
  stats      Stat[]

  @@map("performances")
}

model Stat {
  id            Int         @id @default(autoincrement())
  performanceId Int
  key           String
  value         Float
  performance   Performance @relation(fields: [performanceId], references: [id], onDelete: Cascade)

  @@map("stats")
}

model KPI {
  id            Int         @id @default(autoincrement())
  name          String
  weight        Float
  positionId    String
  performanceId Int
  value         Float
  performance   Performance @relation(fields: [performanceId], references: [id], onDelete: Cascade)
  position      Position    @relation(fields: [positionId], references: [id], onDelete: Cascade)

  @@map("kpis")
}

model Media {
  id          String   @id @default(cuid())
  athleteId   Int
  url         String
  description String?
  createdAt   DateTime @default(now())
  title       String
  type        String
  updatedAt   DateTime @updatedAt
  athlete     Athlete  @relation(fields: [athleteId], references: [id], onDelete: Cascade)

  @@map("media")
}

model Event {
  id                       Int          @id @default(autoincrement())
  athleteId                Int
  title                    String
  location                 String
  eventDate                DateTime
  isPublic                 Boolean
  requiresParentalApproval Boolean
  color                    String?
  description              String?
  endDate                  DateTime?
  athlete                  Athlete      @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  invitations              Invitation[]

  @@map("events")
}

model Invitation {
  id          Int       @id @default(autoincrement())
  eventId     Int
  recruiterId Int
  isIncognito Boolean
  status      String
  sentAt      DateTime  @default(now())
  event       Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  recruiter   Recruiter @relation(fields: [recruiterId], references: [id], onDelete: Cascade)

  @@map("invitations")
}

model Recruiter {
  id            Int            @id @default(autoincrement())
  userId        String         @unique
  organization  String?
  position      String?
  region        String?
  experience    Int?
  invitations   Invitation[]
  notifications Notification[]
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("recruiters")
}

model Notification {
  id          Int        @id @default(autoincrement())
  userId      String
  message     String
  isRead      Boolean    @default(false)
  createdAt   DateTime   @default(now())
  athleteId   Int?
  recruiterId Int?
  athlete     Athlete?   @relation(fields: [athleteId], references: [id])
  Recruiter   Recruiter? @relation(fields: [recruiterId], references: [id])
  userRef     User       @relation(fields: [userId], references: [id])

  @@map("notifications")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

enum UserRole {
  ADMIN
  USER
  ATHLETE
  RECRUITER
}

enum Gender {
  MASCULIN
  FEMININ
}

enum DominantHand {
  GAUCHE
  DROITE
}

enum DominantFoot {
  GAUCHE
  DROITE
}

enum ProgramType {
  CIVILE
  SCOLAIRE
  SCOLAIRE_CIVILE
}

enum SportType {
  BASKETBALL
  SOCCER
  FOOTBALL
  RUGBY
}

enum CategoryLevel {
  BENJAMIN
  CADET
  JUVENILE
  SENIOR
}

// Système de Ranking
model Ranking {
  id          Int      @id @default(autoincrement())
  athleteId   Int
  sportId     String
  positionId  String?  // Optionnel : ranking par position
  scope       RankingScope // GLOBAL, NATIONAL, REGIONAL, LOCAL
  region      String?  // Région pour les rankings régionaux
  country     String?  // Pays pour les rankings nationaux
  rank        Int      // Position dans le classement
  score       Float    // Score calculé
  period      String   // Ex: "2025-Q1", "2025", "all-time"
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  athlete     Athlete  @relation(fields: [athleteId], references: [id], onDelete: Cascade)

  @@unique([athleteId, sportId, scope, period, region, country])
  @@index([sportId, scope, period, rank])
  @@index([athleteId, sportId])
  @@map("rankings")
}

// Badges et Achievements
model Badge {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  icon        String   // Nom de l'icône ou URL
  type        BadgeType
  condition   String   // Description de la condition pour obtenir le badge
  xpReward    Int      @default(0)
  rarity      BadgeRarity @default(COMMON)
  createdAt   DateTime @default(now())

  athletes    AthleteBadge[]

  @@map("badges")
}

model AthleteBadge {
  id          String   @id @default(cuid())
  athleteId   Int
  badgeId     String
  earnedAt    DateTime @default(now())

  athlete     Athlete  @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  badge       Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([athleteId, badgeId])
  @@map("athlete_badges")
}

enum RankingScope {
  GLOBAL      // Mondial
  NATIONAL    // National (par pays)
  REGIONAL    // Régional (par région dans un pays)
  LOCAL       // Local (par ville)
}

enum BadgeType {
  PERFORMANCE   // Badges liés aux performances
  MILESTONE     // Badges liés aux jalons (100 matchs, etc.)
  CONSISTENCY   // Badges liés à la régularité
  ACHIEVEMENT   // Badges liés aux accomplissements
  SPECIAL       // Badges spéciaux/événementiels
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}
